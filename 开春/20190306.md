#### socket过程

#### jdbc过程

#### sevlet过程

#### 流处理

#### 序列化

#### ajax与fetch

#### 排序

#### nio

* http://ifeve.com/netty-2-5/
* https://segmentfault.com/a/1190000009490730
* reactor模型有acceptor、dispatch、handler组成
  * nio的selector就是acceptor，缺少的netty、mina就是dispatch的实现
  * handler的处理便是我们的业务

#### 锁机制

* 乐观锁和悲观锁
  * 乐观锁适合写少读多情况
  * 会占资源
  * 实现方式有版本号和cas算法
* synchronize
  * 只适合单点模式
  * 无法细粒度控制
* redis分布式锁
  * 加锁就set进redis
  * 为了防止死锁设置超时时间
* 如果不放在内存计算的话，有数据库锁保证
  * 4个数据隔离级别和7个传播途径

#### 统一异常处理/返回统一格式

* 首先定义统一返回格式
  * 可以建util文件去重复代码
* 为了返回不同的code字段
  * 新建自己的异常类，要继承runtimeException
  * 新建handler类捕获自己的异常
* 因为如果发生其他异常，返回格式又会不一样
  * 建handler类捕获所有异常，通过条件判断让其返回一样的格式
  * 但是如果是其他异常，为了查看错误原因，应该记录日志
* 最后为了统一魔法值code和message，使用枚举集中状态

#### 权限大全

* 大体有三层
  * 动态菜单
  * 路由守卫
  * 后台权限

#### cookie、session和token

* 攻击
  * 跨站请求伪造[Cross-site request forgery](https://link.jianshu.com/?t=https://en.wikipedia.org/wiki/Cross-site_request_forgery)
    * 针对cookie自动发送
    * jwt选择存在http的heard中
  * 跨站脚本攻击——XSS
    * 针对本地存储和cookie
    * 但是jwt有签名，一般来说安全一点
* token是说直接把验证信息放在token中，直接解密验证，这里一般是放在cookie中
  * 节省空间，但无法控制
* jwt是说直接放token在http的header中

#### rbac权限模型

* 如何拉取用户所有菜单

#### 请求拦截

- filter
  - 可以拿到http的请求参数
- Interceptor
  - 可以获取那个类那个方法
- aspect
  - 可以获取具体参数值

#### 网络错误

401,403,404,405,402

#### 准备难点

* 加密
* 权限

#### mysql索引

- 一般建在where，group by，order by，on
- 因为数据库是分页存储的，所以字段越小越少效率越高
- 联合索引要把离散性更高的放在前面
  - b+树的原因